#!/usr/bin/env bash
#A script written by BeneX-254 in September 4, 2024 under GNU GENERAL PUBLIC LICENSE

# TODO: come up with a better name
fzf_header='
██╗░░░░░██╗██████╗░░░░░░░██╗░░██╗
██║░░░░░██║██╔══██╗░░░░░░╚██╗██╔╝
██║░░░░░██║██████╦╝█████╗░╚███╔╝░
██║░░░░░██║██╔══██╗╚════╝░██╔██╗░
███████╗██║██████╦╝░░░░░░██╔╝╚██╗
╚══════╝╚═╝╚═════╝░░░░░░░╚═╝░░╚═╝
'
CLI_NAME="${0##*/}"
CLI_VERSION="0.1.0"
CLI_AUTHOR="BeneX-254"
use_external_menu=false
load_config() {
  # TODO: Make lib-x(name subject to change) more configurable
  CONFIG_DIR="$HOME/.config/$CLI_NAME"
  DBS_DIR="$CONFIG_DIR/DBS"

  READING_LIST_DB="$DBS_DIR/reading_list"
  PAUSED_LIST_DB="$DBS_DIR/paused_list"
  PLANING_LIST_DB="$DBS_DIR/planing_list"
  RE_READING_LIST_DB="$DBS_DIR/re_reading_list"
  COMPLETED_LIST_DB="$DBS_DIR/completed_list"
  DROPPED_LIST_DB="$DBS_DIR/dropped_list"
  DOCS_LIST_DB="$DBS_DIR/docs_list"

  [ -d "$DBS_DIR" ] || mkdir -p "$DBS_DIR"

  FZF_DEFAULT_OPTS='
    --color=fg:#d0d0d0,fg+:#d0d0d0,bg:#121212,bg+:#262626
    --color=hl:#5f87af,hl+:#5fd7ff,info:#afaf87,marker:#87ff00
    --color=prompt:#d7005f,spinner:#af5fff,pointer:#af5fff,header:#87afaf
    --color=border:#262626,label:#aeaeae,query:#d9d9d9
    --border="rounded" --border-label="" --preview-window="border-rounded" --prompt="> "
    --marker=">" --pointer="◆" --separator="─" --scrollbar="│"
  '
  export FZF_DEFAULT_OPTS

}

init_pretty_print() {
  if [ -t 1 ] && [ "$PRETTY_PRINT" = "y" ] || true; then
    # Check if stdout is a terminal
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    MAGENTA=$(tput setaf 5)
    CYAN=$(tput setaf 6)
    WHITE=$(tput setaf 7)
    BOLD=$(tput bold)
    BLACK=$(tput setaf 0)
    RESET=$(tput sgr0)
  fi

}
fzf-preview() {
  if [[ $# -ne 1 ]]; then
    >&2 echo "usage: $0 FILENAME"
    exit 1
  fi

  file=${1/#\~\//$HOME/}
  type=$(file --dereference --mime -- "$file")

  if [[ ! $type =~ image/ ]]; then
    if [[ $type =~ =binary ]]; then
      file "$1"
      exit
    fi

    # Sometimes bat is installed as batcat.
    if command -v batcat >/dev/null; then
      batname="batcat"
    elif command -v bat >/dev/null; then
      batname="bat"
    else
      cat "$1"
      exit
    fi

    ${batname} --style="${BAT_STYLE:-numbers}" --color=always --pager=never -- "$file"
    exit
  fi

  dim=${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}
  if [[ $dim = x ]]; then
    dim=$(stty size </dev/tty | awk '{print $2 "x" $1}')
  elif ! [[ $KITTY_WINDOW_ID ]] && ((FZF_PREVIEW_TOP + FZF_PREVIEW_LINES == $(stty size </dev/tty | awk '{print $1}'))); then
    # Avoid scrolling issue when the Sixel image touches the bottom of the screen
    # * https://github.com/junegunn/fzf/issues/2544
    dim=${FZF_PREVIEW_COLUMNS}x$((FZF_PREVIEW_LINES - 1))
  fi

  # 1. Use kitty icat on kitty terminal
  if [[ $KITTY_WINDOW_ID ]]; then
    # 1. 'memory' is the fastest option but if you want the image to be scrollable,
    #    you have to use 'stream'.
    #
    # 2. The last line of the output is the ANSI reset code without newline.
    #    This confuses fzf and makes it render scroll offset indicator.
    #    So we remove the last line and append the reset code to its previous line.
    kitty icat --clear --transfer-mode=memory --unicode-placeholder --stdin=no --place="$dim@0x0" "$file" | sed '$d' | sed $'$s/$/\e[m/'

    # 2. Use chafa with Sixel output
  elif command -v chafa >/dev/null; then
    chafa -f sixel -s "$dim" "$file"
    # Add a new line character so that fzf can display multiple images in the preview window
    echo

    # 3. If chafa is not found but imgcat is available, use it on iTerm2
  elif command -v imgcat >/dev/null; then
    # NOTE: We should use https://iterm2.com/utilities/it2check to check if the
    # user is running iTerm2. But for the sake of simplicity, we just assume
    # that's the case here.
    imgcat -W "${dim%%x*}" -H "${dim##*x}" "$file"

    # 4. Cannot find any suitable method to preview the image
  else
    file "$file"
  fi
}
confirm() {
  if command -v "gum" &>/dev/null; then
    gum confirm --default "$1"
  else
    # TODO: Write alternative
    command ...
  fi
}
launcher() {
  if $use_external_menu; then
    rofi -sort -matching fuzzy -dmenu -i -width 1500 -p "" -mesg "Select Action" -matching fuzzy -sorting-method fzf

  else
    fzf \
      --info=hidden \
      --layout=reverse \
      --height=100% \
      --prompt="Select Action: " \
      --header-first --header="$fzf_header" \
      --exact --cycle
  fi

}
launcher_with_preview() {
  if $use_external_menu; then
    rofi -sort -matching fuzzy -dmenu -i -width 1500 -p "" -mesg "Select Action" -matching fuzzy -sorting-method fzf | tr -d "\n"
  else
    fzf \
      --info=hidden \
      --layout=reverse \
      --height=100% \
      --prompt="Select Book: " \
      --header-first --header="$fzf_header" \
      --preview-window=left,35% --bind=right:accept \
      --expect=shift-left,shift-right --tabstop=1 \
      --cycle --exact \
      --ansi --preview="\
      if ! [ -z "{}" ] && ! [ {} = \"Exit\" ] && ! [ {} = \"Main Menu\" ];then\
        CALIBRE_DATA=\"\$(calibredb list --for-machine --fields all)\";\
        book=\$(echo \$CALIBRE_DATA |jq -r 'map(select(.title == \"'{}'\")) | .[0]');\
        book_title=\$(echo  \$book|jq -r '.title');\
        book_authors=\$(echo  \$book|jq -r '.authors');\
        book_tags=\$(echo  \$book|jq -r '.tags[]');\
        book_cover=\$(echo  \$book|jq -r '.cover');\
        book_comments=\$(echo  \$book|jq -r '.comments');\
        book_langs=\$(echo  \$book|jq -r '.languages[]');\
        \
        init_pretty_print;\
        fzf-preview  \"\$book_cover\";
        echo \${MAGENTA}\${BOLD}Title:\${RESET} \$book_title;\
        echo \${MAGENTA}\${BOLD}Authors:\${RESET} \$book_authors;\
        echo -n \${MAGENTA}\${BOLD}Comments:\${RESET};\
        echo  \$book_comments|glow;\
        echo \${MAGENTA}\${BOLD}Tags:\${RESET} \$book_tags;\
        echo \${MAGENTA}\${BOLD}Languages:\${RESET} \$book_langs;\
      else\
        echo Loading;\
      fi;\
      " | tr -d "\n"
  fi
}
main() {
  load_config

  # calibredb list_categories --csv | grep "^$1" | cut -d , -f 2
  # ---- main menu ----
  if [[ -n "$GO_DIRECTLY_TO" ]]; then
    action="$GO_DIRECTLY_TO"
    GO_DIRECTLY_TO=""
  else
    categories=$(calibredb list_categories --csv | tail -n +2 | cut -d , -f 1 | uniq)
    action=$(printf "Reading-List\nPaused\nRe-reading\nPlaning\nCompleted\nDocs\nAll\nRandom\n%s\nExit" "$categories" | launcher)
  fi
  case "$action" in
  # ---- user lists ----
  "Reading-List")
    titles="$(cat "$READING_LIST_DB")"
    ;;
  "Dropped")
    titles="$(cat "$DROPPED_LIST_DB")"
    ;;
  "Paused")
    titles="$(cat "$PAUSED_LIST_DB")"
    ;;
  "Completed")
    titles="$(cat "$COMPLETED_LIST_DB")"
    ;;
  "Re-reading")
    titles="$(cat "$RE_READING_LIST_DB")"
    ;;
  "Planing")
    titles="$(cat "$PLANING_LIST_DB")"
    ;;
  "Docs")
    titles="$(cat "$DOCS_LIST_DB")"
    ;;

  # ---- others ----
  "All")
    titles="$(echo "$CALIBRE_DATA" | jq -r '.[].title')"
    ;;
  "Random")
    titles="$(calibredb list --for-machine --fields=title | jq -r '.[].title' | shuf -n 30)"
    ;;

  # ---- calibre search ----
  "formats")
    series=$(calibredb list_categories --csv | grep "^formats" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "format:$series" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "series")
    series=$(calibredb list_categories --csv | grep "^series" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "series:$series" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "languages")
    language=$(calibredb list_categories --csv | grep "^languages" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "language:$language" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "tags")
    tag=$(calibredb list_categories --csv | grep "^tags" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "tag:$tag" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "rating")
    rating=$(calibredb list_categories --csv | grep "^rating" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "rating:$rating" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "publisher")
    publisher=$(calibredb list_categories --csv | grep "^publisher" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "publisher:$publisher" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "identifiers")
    identifier=$(calibredb list_categories --csv | grep "^identifiers" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "identifier:$identifier" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  "authors")
    series=$(calibredb list_categories --csv | grep "^authors" | cut -d , -f 2 | launcher | tr -d '"')
    titles=$(calibredb list --search "author:$series" --for-machine --fields=title | jq '.[].title' -r)
    ;;
  # ---- others ----
  "Exit")
    exit 0
    ;;
  *)
    echo invalid action
    main
    ;;
  esac
  clear

  # book selection loop
  while true; do
    # ---- select book ----
    SHELL="bash"
    export SHELL
    export -f fzf-preview init_pretty_print
    title=$(printf "%s\nExit\nMain Menu" "$titles" | launcher_with_preview)
    [ "$title" = "Exit" ] && exit 0
    [ "$title" = "Main Menu" ] && break
    clear

    # ---- book actions ----
    action=$(
      printf "Read\nAdd To List\nRemove From List\nMain Menu\nExit" | launcher
    )
    case "$action" in
    "Read")
      book=$(calibredb list --for-machine --fields all | jq "map(select(.title == \"$title\")) | .[0]")
      book_path="$(echo "$book" | jq -r '.formats[0]')"
      open "$book_path" &
      disown
      ;;
    # TODO: create a function to manage list removal and addition
    "Add To List")
      list_to_add_to=$(printf "Reading\nPaused\nPlaning\nRe-reading\nDocs\nCompleted\nDropped" | launcher)
      case "$list_to_add_to" in

      "Reading")
        if grep "^${title}\$" -q <"$READING_LIST_DB"; then
          echo Already in Reading List
          sleep 1
        else
          echo Adding to reading list...
          echo "$title" >>"$READING_LIST_DB"
        fi
        ;;

      "Paused")
        if grep "^${title}\$" -q <"$PAUSED_LIST_DB"; then
          echo Already in paused List
          sleep 1
        else
          echo Adding to paused list...
          echo "$title" >>"$PAUSED_LIST_DB"
        fi
        ;;

      "Re-reading")
        if grep "^${title}\$" -q <"$RE_READING_LIST_DB"; then
          echo Already in re-reading List
          sleep 1
        else
          echo Adding to re-reading list...
          echo "$title" >>"$RE_READING_LIST_DB"
        fi
        ;;

      "Completed")
        if grep "^${title}\$" -q <"$COMPLETED_LIST_DB"; then
          echo Already in completed List
          sleep 1
        else
          echo Adding to completed list...
          echo "$title" >>"$COMPLETED_LIST_DB"
        fi
        ;;

      "Docs")
        if grep "^${title}\$" -q <"$DOCS_LIST_DB"; then
          echo Already in docs List
          sleep 1
        else
          echo Adding to docs list...
          echo "$title" >>"$DOCS_LIST_DB"
        fi
        ;;

      "Planing")
        if grep "^${title}\$" -q <"$PLANING_LIST_DB"; then
          echo Already in planing List
          sleep 1
        else
          echo Adding to planing list...
          echo "$title" >>"$PLANING_LIST_DB"
        fi
        ;;
      "Dropped")
        if grep "^${title}\$" -q <"$DROPPED_LIST_DB"; then
          echo Already in dropped List
          sleep 1
        else
          echo Adding to dropped list...
          echo "$title" >>"$DROPPED_LIST_DB"
        fi
        ;;
      *)
        echo unknown option
        ;;
      esac
      ;;
    "Remove From List")
      if grep "^$title\$" -q <"$COMPLETED_LIST_DB"; then
        if confirm "Are you sure you want to remove '$title' from  completed list?"; then
          echo removing from reading list...
          sed -i -E "s/${title}//g" "$READING_LIST_DB"
        fi
      else
        echo "$title" is not in your completed list
        sleep 1
      fi
      ;;
    "Exit")
      exit 0
      ;;
    "Main Menu")
      main
      ;;

    *)
      echo invalid action
      sleep 1
      ;;
    esac
    clear
  done
  main
}

# ---- cli ----
usage() {
  printf "\
Usage: %s [arguments] [options] 

Most of the options are directly passed to calibredb

Options:
  -s, --search
    search for a book based on calibredb search syntax
  -S, --sort-by 
    sort the books on a specified field
  -g, --go-directly-to
    open $CLI_NAME with a sub-menu pre-selected
  -h, --help
    Show this help message and exit
  -v, --version
    print the $CLI_NAME version and exit

arguments:
  completions
    generates shell completions for $CLI_NAME

Examples:
  $CLI_NAME --search tag:chess
  $CLI_NAME --sort-by size 
  $CLI_NAME --go-directly-to Reading-List 

" "$CLI_NAME"
  exit "$1"
}
# TODO: write an option that specifies a direct go to a particular menu
GO_DIRECTLY_TO=""
case "$1" in
-h | --help)
  usage 0
  ;;
-v | --version)
  echo "$CLI_NAME $CLI_VERSION Copyright © 2024 $CLI_AUTHOR projects"
  exit 0
  ;;
-s | --search)
  [ -n "$2" ] || usage 1
  CALIBRE_DATA="$(calibredb list --for-machine --fields=title --search "$2")"
  GO_DIRECTLY_TO="All"
  ;;
-g | --go-directly-to)
  [ -n "$2" ] || usage 1
  GO_DIRECTLY_TO="$2"
  CALIBRE_DATA="$(calibredb list --for-machine --fields title)"
  ;;
-S | --sort-by)
  [ -n "$2" ] || usage 1
  CALIBRE_DATA="$(calibredb list --for-machine --fields title --sort-by "$2")"
  GO_DIRECTLY_TO="All"
  ;;
completions)
  [ -n "$2" ] || usage 1
  case "$2" in
  -f | --fish)
    echo "\
# --- functions ---
function _lib_x_complete_search
  for comp_line in (calibredb list_categories --csv) 
    set comp_key (echo \$comp_line|cut --delimiter , --fields 1)
    set comp_val (echo \$comp_line|cut --delimiter , --fields 2|tr -d '\"')
    echo "\$comp_key:\$comp_val"
  end
end

# --- completions ---
complete -c $CLI_NAME --no-files --short-option h --long-option help --description 'Print a short help text and exit'
complete -c $CLI_NAME --no-files --short-option v --long-option version --description 'Print a short version string and exit' --condition 'not __fish_seen_subcommand_from completions'

complete -c $CLI_NAME --no-files --short-option S --long-option sort-by --description 'Sort the books by a field' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments 'author_sort authors comments cover formats identifiers isbn languages last_modified pubdate publisher rating series series_index size tags template timestamp title uuid'
complete -c $CLI_NAME --no-files --short-option g --long-option go-directly-to --description 'Open $CLI_NAME with a sub-menu pre-selected' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments 'All Reading-List Paused Planing Re-reading Completed Docs Random authors formats identifiers languages  publisher rating series tags'
complete -c $CLI_NAME --no-files --short-option s --long-option search --description 'search for a book' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments \"(_lib_x_complete_search)\"

complete -c $CLI_NAME --no-files --arguments \"completions\" --condition 'not __fish_contains_opt search s sort-by S'
complete -c $CLI_NAME --no-files --short-option z --long-option zsh --description 'print zsh completions' --condition '__fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option b --long-option bash --description 'print bash completions' --condition '__fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option f --long-option fish --description 'print fish completions' --condition '__fish_seen_subcommand_from completions'
    "
    ;;
  -b | --bash)
    # TODO: write bash completions
    command ...
    ;;
  -z | --zsh)
    # TODO: write zsh completions
    command ...
    ;;
  -h | --help)
    echo "\
Generate shell completions for $CLI_NAME

Options:
  --fish
    print fish completions and exit
  --bash
    print bash completions and exit
  --zsh
    print zsh completions and exit

Example:
  $CLI_NAME completions --fish
  $CLI_NAME completions --bash
  $CLI_NAME completions --zsh
    "
    ;;
  *)
    echo "\
Generate shell completions for $CLI_NAME

Options:
  --fish
    print fish completions and exit
  --bash
    print bash completions and exit
  --zsh
    print zsh completions and exit

Example:
  $CLI_NAME completions --fish
  $CLI_NAME completions --bash
  $CLI_NAME completions --zsh
    "
    exit 1
    ;;

  esac
  exit 0
  ;;

*)
  CALIBRE_DATA="$(calibredb list --for-machine --fields title)"
  ;;
esac
main
